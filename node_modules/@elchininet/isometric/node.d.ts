declare enum SVG_ELEMENTS {
    svg = "svg",
    group = "g",
    path = "path",
    rect = "rect",
    text = "text",
    tspan = "tspan",
    pattern = "pattern",
    image = "image",
    animate = "animate",
    animateTransform = "animateTransform"
}
declare enum LineCap {
    butt = "butt",
    square = "square",
    round = "round"
}
declare enum LineJoin {
    miter = "miter",
    round = "round",
    bevel = "bevel"
}
declare enum Command {
    move = "move",
    line = "line",
    curve = "curve"
}
declare enum PlaneView {
    FRONT = "FRONT",
    SIDE = "SIDE",
    TOP = "TOP"
}
declare enum Axis {
    RIGHT = "RIGHT",
    LEFT = "LEFT",
    TOP = "TOP"
}
declare enum ORIGIN {
    CENTER = "center",
    LEFT = "left",
    RIGHT = "right",
    TOP = "top",
    BOTTOM = "bottom"
}
type StringOrNumber = string | number;
type AddEventListenerCallback = (event?: Event) => void;
type RequestAnimationFrame = typeof window.requestAnimationFrame;
declare global {
    interface Window {
        mozRequestAnimationFrame: RequestAnimationFrame;
        webkitRequestAnimationFrame: RequestAnimationFrame;
        msRequestAnimationFrame: RequestAnimationFrame;
    }
}
type IsometricPlaneView = keyof typeof PlaneView;
type IsometricAxis = keyof typeof Axis;
type IsometricPoint = {
    x: number;
    y: number;
};
interface Point {
    r?: number;
    l?: number;
    t?: number;
}
interface LinePoint {
    command: Exclude<Command, Command.curve>;
    control?: never;
    point: Point;
}
interface CurvePoint {
    command: Exclude<Command, Command.move | Command.line>;
    control: Point;
    point: Point;
}
type CommandPoint = LinePoint | CurvePoint;
interface Rotation {
    axis: IsometricAxis;
    value: number;
}
interface Texture {
    url: string;
    planeView?: IsometricPlaneView;
    height?: number;
    width?: number;
    scale?: number;
    shift?: {
        right?: number;
        left?: number;
        top?: number;
    };
    rotation?: Rotation;
    pixelated?: boolean;
}
interface Position {
    right: number;
    left: number;
    top: number;
}
type StrokeLinecap = keyof typeof LineCap;
type StrokeLinejoin = keyof typeof LineJoin;
type SVGProperties = "fillColor" | "fillOpacity" | "strokeColor" | "strokeOpacity" | "strokeWidth";
type SVGPathProperties = "path";
type SVGPositionableProperties = "left" | "right" | "top";
type SVGRectangleProperties = "width" | "height";
type SVGCircleProperties = "radius";
type SVGTextProperties = "rotation";
type SVGAnimationProperties = SVGProperties | SVGPathProperties | SVGPositionableProperties | SVGRectangleProperties | SVGCircleProperties | SVGTextProperties;
type SVGAnimationBase = {
    property: SVGAnimationProperties;
    duration?: number;
    repeat?: number;
};
type SVGAnimationProps = {
    from: StringOrNumber;
    to: StringOrNumber;
    values?: never;
} | {
    from?: never;
    to?: never;
    values: StringOrNumber | StringOrNumber[];
};
type SVGAnimation = SVGAnimationBase & SVGAnimationProps;
type SVGPathAnimation = SVGAnimation & {
    property: SVGProperties | SVGPathProperties;
};
type SVGRectangleAnimation = SVGAnimation & {
    property: SVGProperties | SVGPositionableProperties | SVGRectangleProperties;
};
type SVGCircleAnimation = SVGAnimation & {
    property: SVGProperties | SVGPositionableProperties | SVGCircleProperties;
};
type SVGAnimationObject = SVGAnimation & {
    element?: SVGAnimateElement;
};
type Listener = {
    fn: VoidFunction;
    fnBind: VoidFunction;
};
declare class Store {
    constructor(width: number, height: number, scale: number);
    private sizes;
    get width(): number;
    set width(value: number);
    get height(): number;
    set height(value: number);
    get scale(): number;
    set scale(value: number);
    get centerX(): number;
    get centerY(): number;
}
declare abstract class IsometricStore {
    protected dataStore: Store;
    get data(): Store;
    set data(store: Store);
}
declare abstract class IsometricElementAbstract extends IsometricStore {
    constructor(svgElement: SVG_ELEMENTS);
    protected element: SVGElement;
    protected listeners: Listener[];
    abstract update(): this;
    abstract clear(): this;
    getElement(): SVGElement;
    addEventListener(event: string, callback: AddEventListenerCallback, useCapture?: boolean): this;
    removeEventListener(event: string, callback: AddEventListenerCallback, useCapture?: boolean): this;
}
interface IsometricGraphicProps {
    fillColor?: string;
    fillOpacity?: number;
    strokeColor?: string;
    strokeDashArray?: number[];
    strokeLinecap?: StrokeLinecap;
    strokeLinejoin?: StrokeLinejoin;
    strokeOpacity?: number;
    strokeWidth?: number;
    texture?: Texture;
}
declare abstract class IsometricGraphicAbstract extends IsometricElementAbstract {
    constructor(props: IsometricGraphicProps, svgElement: SVG_ELEMENTS);
    private createTexture;
    private _updateTexture;
    protected props: IsometricGraphicProps;
    protected patternId: string;
    protected pattern: SVGPatternElement;
    protected animations: SVGAnimationObject[];
    protected abstract updateSubClassAnimations(): void;
    protected addAnimationBasicProperties(attributeName: string, animation: SVGAnimationObject): void;
    protected updateAnimations(): void;
    protected updatePatternTransform(corner: IsometricPoint, planeView?: IsometricPlaneView): void;
    get fillColor(): string;
    set fillColor(value: string);
    get fillOpacity(): number;
    set fillOpacity(value: number);
    set texture(value: Texture);
    get texture(): Texture;
    get strokeColor(): string;
    set strokeColor(value: string);
    get strokeDashArray(): number[];
    set strokeDashArray(value: number[]);
    get strokeLinecap(): StrokeLinecap;
    set strokeLinecap(value: StrokeLinecap);
    get strokeLinejoin(): StrokeLinejoin;
    set strokeLinejoin(value: StrokeLinejoin);
    get strokeOpacity(): number;
    set strokeOpacity(value: number);
    get strokeWidth(): number;
    set strokeWidth(value: number);
    getPattern(): SVGPatternElement | undefined;
    updateTexture(value: Partial<Texture>): this;
    addAnimation(animation: SVGAnimation): this;
    removeAnimationByIndex(index: number): this;
    removeAnimations(): this;
}
declare class IsometricContainerAbstract extends IsometricElementAbstract {
    constructor(svgElement: SVG_ELEMENTS);
    protected _children: IsometricElementAbstract[];
    private getChildIndex;
    private throwChildError;
    protected removeSVGChild(child: IsometricElementAbstract): void;
    protected insertPattern(pattern?: SVGPatternElement): void;
    get children(): IsometricElementAbstract[];
    update(): this;
    clear(): this;
    addChild(child: IsometricElementAbstract): this;
    addChildren(...children: IsometricElementAbstract[]): this;
    removeChild(child: IsometricElementAbstract): this;
    removeChildren(...children: IsometricElementAbstract[]): this;
    removeChildByIndex(index: number): this;
    setChildIndex(child: IsometricElementAbstract, index: number): this;
    bringChildToFront(child: IsometricElementAbstract): this;
    bringChildForward(child: IsometricElementAbstract): this;
    sendChildToBack(child: IsometricElementAbstract): this;
    sendChildBackward(child: IsometricElementAbstract): this;
}
interface IsometricCanvasProps {
    container?: HTMLElement | string;
    backgroundColor?: string;
    scale?: number;
    height?: number;
    width?: number;
}
declare class IsometricCanvas extends IsometricContainerAbstract {
    constructor(props?: IsometricCanvasProps);
    private props;
    private background;
    private isAnimated;
    getSVGCode(): string;
    get backgroundColor(): string;
    set backgroundColor(value: string);
    get scale(): number;
    set scale(value: number);
    get height(): number;
    set height(value: number);
    get width(): number;
    set width(value: number);
    get animated(): boolean;
    pauseAnimations(): IsometricCanvas;
    resumeAnimations(): IsometricCanvas;
}
interface IsometricDraggableProps {
    right?: number;
    left?: number;
    top?: number;
}
type Bounds = [
    number,
    number
];
type Drag = IsometricPlaneView | false;
type Boundaries = Partial<Record<keyof Position, Bounds>> | false;
declare abstract class IsometricDraggableAbstract extends IsometricElementAbstract {
    protected props: IsometricDraggableProps;
    private _drag;
    private _bounds;
    private _dragStore;
    private _coords;
    private _update;
    private _dragging;
    private _prevented;
    private setup;
    private betweenBounds;
    private getRight;
    private getLeft;
    private getTop;
    private getFixedCoordinates;
    private dispatchEvent;
    private animate;
    private startDrag;
    private moveElement;
    private dropElement;
    private beginDrag;
    private stopDrag;
    get right(): number;
    set right(value: number);
    get left(): number;
    set left(value: number);
    get top(): number;
    set top(value: number);
    get drag(): Drag;
    set drag(value: Drag);
    get bounds(): Boundaries;
    set bounds(value: Boundaries);
}
type IsometricGroupProps = IsometricDraggableProps;
declare class IsometricGroup extends IsometricContainerAbstract {
    constructor(props?: IsometricGroupProps);
    protected props: IsometricGroupProps;
    update(): this;
}
interface IsometricGroup extends IsometricDraggableAbstract {
}
declare abstract class IsometricPathAbstract extends IsometricGraphicAbstract {
    constructor(props: IsometricGraphicProps, svgElement: SVG_ELEMENTS);
    protected abstract getCommands(args?: unknown): CommandPoint[];
    protected updateGraphic(planeView?: IsometricPlaneView, autoclose?: boolean): void;
}
interface IsometricShapeProps extends IsometricGraphicProps, IsometricDraggableProps {
    planeView: IsometricPlaneView;
}
declare abstract class IsometricShapeAbstract extends IsometricPathAbstract {
    constructor(props: IsometricShapeProps);
    protected props: IsometricShapeProps;
    update(): this;
    clear(): this;
    get planeView(): IsometricPlaneView;
    set planeView(value: IsometricPlaneView);
}
interface IsometricShapeAbstract extends IsometricDraggableAbstract {
}
interface IsometricRectangleProps extends IsometricShapeProps {
    height: number;
    width: number;
}
interface GetRectanglePathArguments {
    right: number;
    left: number;
    top: number;
    width: number;
    height: number;
}
declare class IsometricRectangle extends IsometricShapeAbstract {
    constructor(props: IsometricRectangleProps);
    private _width;
    private _height;
    protected getCommands(args?: GetRectanglePathArguments): CommandPoint[];
    private getRectanglePath;
    protected updateSubClassAnimations(): void;
    get width(): number;
    set width(value: number);
    get height(): number;
    set height(value: number);
    addAnimation(animation: SVGRectangleAnimation): this;
}
interface IsometricCircleProps extends IsometricShapeProps {
    radius: number;
}
interface GetCirclePathArguments {
    right: number;
    left: number;
    top: number;
    radius: number;
}
declare class IsometricCircle extends IsometricShapeAbstract {
    constructor(props: IsometricCircleProps);
    private _radius;
    protected getCommands(args?: GetCirclePathArguments): CommandPoint[];
    private getCirclePath;
    protected updateSubClassAnimations(): void;
    get radius(): number;
    set radius(value: number);
    addAnimation(animation: SVGCircleAnimation): this;
}
interface IsometricPathProps extends IsometricGraphicProps {
    autoclose?: boolean;
}
declare class IsometricPath extends IsometricPathAbstract {
    constructor(props?: IsometricPathProps);
    private commands;
    private _autoclose;
    private getPathFromCommands;
    protected updateSubClassAnimations(): void;
    protected getCommands(): CommandPoint[];
    get autoclose(): boolean;
    set autoclose(value: boolean);
    update(): this;
    clear(): this;
    moveTo(right: number, left: number, top: number): IsometricPath;
    lineTo(right: number, left: number, top: number): IsometricPath;
    curveTo(controlRight: number, controlLeft: number, controlTop: number, right: number, left: number, top: number): IsometricPath;
    mt(right: number, left: number, top: number): IsometricPath;
    lt(right: number, left: number, top: number): IsometricPath;
    ct(controlRight: number, controlLeft: number, controlTop: number, right: number, left: number, top: number): IsometricPath;
    draw(commands: string): IsometricPath;
    addAnimation(animation: SVGPathAnimation): this;
}
interface IsometricTextProps extends IsometricGraphicProps, IsometricDraggableProps {
    planeView: IsometricPlaneView;
    text?: string;
    fontFamily?: string;
    fontSize?: number;
    fontStyle?: "normal" | "italic" | "oblique";
    fontWeight?: "normal" | "bold" | "bolder" | "lighter" | number;
    rotation?: number;
    selectable?: boolean;
    origin?: [
        `${Extract<ORIGIN.LEFT | ORIGIN.CENTER | ORIGIN.RIGHT, ORIGIN>}`,
        `${Extract<ORIGIN.TOP | ORIGIN.CENTER | ORIGIN.BOTTOM, ORIGIN>}`
    ];
}
declare class IsometricText extends IsometricGraphicAbstract {
    constructor(props: IsometricTextProps);
    private _textElement;
    private _tspan;
    private _text;
    private _planeView;
    private _fontFamily;
    private _fontSize;
    private _fontStyle;
    private _fontWeight;
    private _origin;
    private _selectable;
    private _right;
    private _left;
    private _top;
    private _rotation;
    private _originHash;
    private commonAnimationAttributes;
    private getPositionTransform;
    private getMatrixTransform;
    protected updateSubClassAnimations(): void;
    update(): this;
    clear(): this;
    get text(): string;
    set text(value: string);
    get planeView(): IsometricPlaneView;
    set planeView(value: IsometricPlaneView);
    get fontFamily(): string;
    set fontFamily(value: string);
    get fontSize(): number;
    set fontSize(value: number);
    get fontStyle(): IsometricTextProps["fontStyle"];
    set fontStyle(value: IsometricTextProps["fontStyle"]);
    get fontWeight(): IsometricTextProps["fontWeight"];
    set fontWeight(value: IsometricTextProps["fontWeight"]);
    get selectable(): boolean;
    set selectable(value: boolean);
    get origin(): IsometricTextProps["origin"];
    set origin(value: IsometricTextProps["origin"]);
    get right(): number;
    set right(value: number);
    get left(): number;
    set left(value: number);
    get top(): number;
    set top(value: number);
    get rotation(): number;
    set rotation(value: number);
}
export { LineCap, LineJoin, PlaneView, Axis, SVGPathAnimation, SVGRectangleAnimation, SVGCircleAnimation, IsometricGraphicProps, IsometricCanvas, IsometricCanvasProps, IsometricGroup, IsometricGroupProps, IsometricRectangle, IsometricRectangleProps, IsometricCircle, IsometricCircleProps, IsometricPath, IsometricPathProps, IsometricText, IsometricTextProps };
